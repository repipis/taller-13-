import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error
import sklearn
from sklearn.preprocessing import OrdinalEncoder, MinMaxScaler, RobustScaler
from sklearn.model_selection import train_test_split

df = pd.read_csv('toyota.csv')

df_ohe = pd.get_dummies(df)
scaler = RobustScaler()
df_scl_ohe = scaler.fit_transform(df_ohe)
df_scl_ohe = pd.DataFrame(df_scl_ohe, columns = df_ohe.columns)

X = df_scl_ohe.drop(['price'], axis=1)
y = df_scl_ohe['price']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=22)

X_train_array = np.c_[np.ones(X_train.values.shape[0]), X_train.values]
y_train_array = y_train.values
X_test_array = np.c_[np.ones(X_test.values.shape[0]), X_test.values]
y_test_array = y_test.values

w0 = np.random.rand(X_train_array.shape[1])
w = w0.copy()
#Inicialización de criterio de parada
eps = 1e-4  # Se define un criterio de parada basado en el error en la predicción #
error = float('inf')  # Valor inicial, se debe actualizar en cada iteración #
dif = float('inf')   # Diferencia entre vectores de pesos w consecutivos #
tasa = 0.001  
errores = [] # Agregar a esta lista los valores de la función de error en cada iteración #

while dif > eps:
    w_anterior = w.copy()
    for i in range(0, len(X_train_array)):
        xActual = X_train_array[i]
        yActual = y_train_array[i]
        y_pred = np.dot(w, xActual)
        ep = y_pred - yActual
        gradiente = 2 * ep * xActual
        t = tasa*gradiente
        w = w - t
    g = X_train_array @ w
    error = np.mean((g - y_train_array) ** 2)
    errores.append(error)
    dif = np.linalg.norm(w - w_anterior)

y_train_preds = np.zeros(y_train_array.shape)
for i in range(X_train_array.shape[0]):
    y_train_preds[i] = np.dot(w,X_train_array[i])

y_test_preds = np.zeros(y_test_array.shape)
for i in range(X_test_array.shape[0]):
    y_test_preds[i] = np.dot(w,X_test_array[i])
    
r2_train = r2_score(y_train_array, y_train_preds)
r2_test = r2_score(y_test_array, y_test_preds)
print(f'R2 entrenamiento: {round(r2_train,4)}\nR2 prueba: {round(r2_test,4)}')
